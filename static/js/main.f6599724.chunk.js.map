{"version":3,"sources":["CandyMachine/index.js","CandyMachine/connection.js","CountdownTimer/index.js","assets/twitter-logo.svg","App.js","index.js","CandyMachine/helpers.js"],"names":["SystemProgram","web3","opts","CandyMachine","walletAddress","useState","candyMachine","setCandyMachine","isMinting","setIsMinting","isLoadingMints","setIsLoadingMints","getCandyMachineCreator","a","candyMachineID","PublicKey","findProgramAddress","Buffer","from","toBuffer","candyMachineProgram","getMetadata","mint","TOKEN_METADATA_PROGRAM_ID","getMasterEdition","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","splTokenMintAddress","keys","pubkey","isSigner","isWritable","programId","TOKEN_PROGRAM_ID","SYSVAR_RENT_PUBKEY","TransactionInstruction","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","data","mintToken","Keypair","generate","getAtaForMint","publicKey","userTokenAccountAddress","state","tokenMint","userPayingAccountAddress","candyMachineAddress","id","remainingAccounts","signers","cleanupInstructions","MintLayout","span","program","provider","connection","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","instructions","gatekeeper","getNetworkToken","gatekeeperNetwork","push","expireOnUse","CIVIC","getNetworkExpire","whitelistMintSettings","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","price","toNumber","metadataAddress","masterEdition","candyMachineCreator","creatorBump","instruction","mintNft","accounts","wallet","treasury","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","undefined","sendTransactions","txs","map","t","txid","console","log","useEffect","getCandyMachineState","getProvider","Connection","process","Provider","window","solana","Program","fetchIdl","idl","account","fetch","itemsAvailable","itemsRedeemed","itemsRemaining","goLiveData","goLiveDate","presale","Date","getTime","goLiveDateTimeString","toGMTString","isSoldOut","isActive","endSettings","endSettingType","date","number","isPresale","hiddenSettings","className","currentDate","dropDate","renderDropTimer","onClick","disabled","instructionSet","signersSet","sequenceType","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","transaction","Transaction","forEach","add","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","catch","reason","Promise","all","getUnixTs","DEFAULT_TIMEOUT","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","CountdownTimer","timerString","setTimerString","interval","setInterval","distance","days","Math","floor","hours","minutes","seconds","clearInterval","TWITTER_HANDLE","TWITTER_LINK","App","setWalletAddress","checkIfWalletIsConnected","isPhantom","connect","onlyIfTrusted","response","alert","connectWallet","onLoad","addEventListener","removeEventListener","alt","src","twitterLogo","href","target","rel","ReactDOM","render","StrictMode","document","getElementById","anchor","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","buyer"],"mappings":"iPAkBQA,EAAkBC,IAAlBD,cACFE,EACiB,YAkaRC,IA/ZM,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAEtB,EAAwCC,mBAAS,MAAjD,mBAAOC,EAAP,KAAqBC,EAArB,KACA,EAAkCF,oBAAS,GAA3C,mBAAOG,EAAP,KAAkBC,EAAlB,KACA,EAA4CJ,oBAAS,GAArD,mBAAOK,EAAP,KAAuBC,EAAvB,KAEMC,EAAsB,uCAAG,WAAON,GAAP,eAAAO,EAAA,6DACvBC,EAAiB,IAAIC,YAAUT,GADR,SAEhBL,IAAKc,UAAUC,mBACxB,CAACC,EAAOC,KAAK,iBAAkBJ,EAAeK,YAC9CC,KAJyB,mFAAH,sDAQtBC,EAAW,uCAAG,WAAOC,GAAP,SAAAT,EAAA,sEAEVE,YAAUC,mBACd,CACEC,EAAOC,KAAK,YACZK,IAA0BJ,WAC1BG,EAAKH,YAEPI,KARc,uCAUhB,IAVgB,2CAAH,sDAaXC,EAAgB,uCAAG,WAAOF,GAAP,SAAAT,EAAA,sEAEfE,YAAUC,mBACd,CACEC,EAAOC,KAAK,YACZK,IAA0BJ,WAC1BG,EAAKH,WACLF,EAAOC,KAAK,YAEdK,KATmB,uCAWrB,IAXqB,2CAAH,sDAchBE,EAA0C,SAC9CC,EACAC,EACAvB,EACAwB,GAEA,IAAMC,EAAO,CACX,CAAEC,OAAQH,EAAOI,UAAU,EAAMC,YAAY,GAC7C,CAAEF,OAAQJ,EAAwBK,UAAU,EAAOC,YAAY,GAC/D,CAAEF,OAAQ1B,EAAe2B,UAAU,EAAOC,YAAY,GACtD,CAAEF,OAAQF,EAAqBG,UAAU,EAAOC,YAAY,GAC5D,CACEF,OAAQ7B,IAAKD,cAAciC,UAC3BF,UAAU,EACVC,YAAY,GAEd,CAAEF,OAAQI,IAAkBH,UAAU,EAAOC,YAAY,GACzD,CACEF,OAAQ7B,IAAKkC,mBACbJ,UAAU,EACVC,YAAY,IAGhB,OAAO,IAAI/B,IAAKmC,uBAAuB,CACrCP,OACAI,UAAWI,IACXC,KAAMrB,EAAOC,KAAK,OAIhBqB,EAAS,uCAAG,8DAAA1B,EAAA,6DAChBJ,GAAa,GAEPa,EAAOrB,IAAKuC,QAAQC,WAHV,SAMRC,YAAcpB,EAAKqB,UAAWvC,EAAcuC,WANpC,UAKVC,EALU,OAOd,IAE+BtC,EAAauC,MAAMC,UATpC,iCAULJ,YAAcpC,EAAauC,MAAMC,UAAW1C,EAAcuC,WAVrD,mBAUiE,GAVjE,6BAWZvC,EAAcuC,UAXF,eASVI,EATU,KAaVC,EAAsB1C,EAAa2C,GACnCC,EAAoB,GACpBC,EAAU,CAAC7B,GACX8B,EAAsB,GAhBZ,KAkBdnD,IAAKD,cAlBS,KAmBAI,EAAcuC,UAnBd,KAoBMrB,EAAKqB,UApBX,KAqBLU,IAAWC,KArBN,UAuBJhD,EAAaiD,QAAQC,SAASC,WAAWC,kCAC7CL,IAAWC,MAxBH,4BA0BDpB,IA1BC,MAmBZyB,WAnBY,KAoBZC,iBApBY,KAqBZC,MArBY,KAsBZC,SAtBY,KA0BZ7B,UA1BY,gBAkBK8B,cAlBL,qBA4BdC,IAAMC,0BACJ/B,IACAZ,EAAKqB,UACL,EACAvC,EAAcuC,UACdvC,EAAcuC,WAjCF,MAmCdlB,EACEmB,EACAxC,EAAcuC,UACdvC,EAAcuC,UACdrB,EAAKqB,WAvCO,MAyCdqB,IAAME,wBACJhC,IACAZ,EAAKqB,UACLC,EACAxC,EAAcuC,UACd,GACA,GA9BEwB,EAjBU,yBAmDZ7D,EAAauC,MAAMuB,WAnDP,8BAoDdlB,EApDc,UAsDJmB,YACJjE,EAAcuC,UACdrC,EAAauC,MAAMuB,WAAWE,mBAxDtB,wBA0DV,GA1DU,OAqDZxC,OArDY,MA2DZE,YAAY,EACZD,UAAU,GA5DE,MAoDIwC,KApDJ,mBA8DVjE,EAAauC,MAAMuB,WAAWI,YA9DpB,wBA+DZtB,EAAkBqB,KAAK,CACrBzC,OAAQ2C,IACRzC,YAAY,EACZD,UAAU,IAlEA,MAoEZmB,EApEY,UAsEFwB,YACJpE,EAAauC,MAAMuB,WAAWE,mBAvExB,qBAyER,GAzEQ,OAqEVxC,OArEU,MA0EVE,YAAY,EACZD,UAAU,GA3EA,MAoEMwC,KApEN,8BA+EZjE,EAAauC,MAAM8B,sBA/EP,wBAgFRrD,EAAO,IAAIrB,IAAKc,UACpBT,EAAauC,MAAM8B,sBAAsBrD,MAjF7B,UAoFgBoB,YAAcpB,EAAMlB,EAAcuC,WApFlD,WAoFRiC,EApFQ,OAoF8D,GAC5E1B,EAAkBqB,KAAK,CACrBzC,OAAQ8C,EACR5C,YAAY,EACZD,UAAU,KAGRzB,EAAauC,MAAM8B,sBAAsBE,KAAKC,cA3FpC,wBA4FNC,EAAyB9E,IAAKuC,QAAQC,WAE5CS,EAAkBqB,KAAK,CACrBzC,OAAQR,EACRU,YAAY,EACZD,UAAU,IAEZmB,EAAkBqB,KAAK,CACrBzC,OAAQiD,EAAuBpC,UAC/BX,YAAY,EACZD,UAAU,IAEZoB,EAAQoB,KAAKQ,GAxGD,UA0GJzE,EAAaiD,QAAQC,SAASC,WAAWuB,eAC7CJ,GA3GQ,iBA8GVT,EAAaI,KACXP,IAAMiB,yBACJ/C,IACA0C,EACAG,EAAuBpC,UACvBvC,EAAcuC,UACd,GACA,IAGJS,EAAoBmB,KAClBP,IAAMkB,wBACJhD,IACA0C,EACAxE,EAAcuC,UACd,MA7HM,eAoIZrC,EAAauC,MAAMC,YACfqC,EAAoBlF,IAAKuC,QAAQC,WAEvCU,EAAQoB,KAAKY,GACbjC,EAAkBqB,KAAK,CACrBzC,OAAQiB,EACRf,YAAY,EACZD,UAAU,IAEZmB,EAAkBqB,KAAK,CACrBzC,OAAQqD,EAAkBxC,UAC1BX,YAAY,EACZD,UAAU,IAGZoC,EAAaI,KACXP,IAAMiB,yBACJ/C,IACAa,EACAoC,EAAkBxC,UAClBvC,EAAcuC,UACd,GACArC,EAAauC,MAAMuC,MAAMC,aAG7BjC,EAAoBmB,KAClBP,IAAMkB,wBACJhD,IACAa,EACA3C,EAAcuC,UACd,MAlKU,UAsKctB,EAAYC,EAAKqB,WAtK/B,eAsKV2C,EAtKU,iBAuKY9D,EAAiBF,EAAKqB,WAvKlC,eAuKV4C,EAvKU,iBAyKiC3E,EAC/CoC,GA1Kc,2CAyKTwC,EAzKS,KAyKYC,EAzKZ,WA6KhBtB,EA7KgB,UA8KR7D,EAAaiD,QAAQmC,YAAYC,QAAQF,EAAa,CAC1DG,SAAU,CACRtF,aAAc0C,EACdwC,sBACA7D,MAAOvB,EAAcuC,UACrBkD,OAAQvF,EAAauC,MAAMiD,SAC3BxE,KAAMA,EAAKqB,UACXoD,SAAUT,EACVC,gBACAS,cAAe5F,EAAcuC,UAC7BsD,gBAAiB7F,EAAcuC,UAC/BuD,qBAAsB3E,IACtB4E,aAAcjE,IACdkE,cAAepG,EAAciC,UAC7BoE,KAAMpG,IAAKkC,mBACXmE,MAAOrG,IAAKsG,oBACZC,kBAAmBvG,IAAKwG,iCACxBC,yBAA0BzG,IAAK0G,4BAEjCzD,kBACEA,EAAkB0D,OAAS,EAAI1D,OAAoB2D,IAlMzC,kCA6KHtC,KA7KG,4BAuMd9D,GAAa,GAvMC,UAyMNqG,YACJxG,EAAaiD,QAAQC,SAASC,WAC9BnD,EAAaiD,QAAQC,SAASqC,OAC9B,CAAC1B,EAAcf,GACf,CAACD,EAAS,KA7MA,wCA+MZ4D,IAAIC,KAAI,SAAAC,GAAC,OAAIA,EAAEC,SA/MH,oCAiNdC,QAAQC,IAAR,OAjNc,eAmNhB3G,GAAa,GAnNG,kBAoNT,IApNS,2DAAH,qDAuNf4G,qBAAU,WACRC,MACC,IAEH,IAAMC,EAAc,WAClB,IAEM9D,EAAa,IAAI+D,aAFPC,0CAWhB,OANiB,IAAIC,IACnBjE,EACAkE,OAAOC,OACP1H,IAOAoH,EAAoB,uCAAG,8CAAAzG,EAAA,6DAE3BF,GAAkB,GAEZ6C,EAAW+D,IAJU,SAOTM,IAAQC,SAAS1G,IAAqBoC,GAP7B,cAOrBuE,EAPqB,OAUrBxE,EAAU,IAAIsE,IAAQE,EAAK3G,IAAqBoC,GAV3B,SAaAD,EAAQyE,QAAQ1H,aAAa2H,MACtDR,+CAdyB,OAarBnH,EAbqB,OAkBrB4H,EAAiB5H,EAAagC,KAAK4F,eAAe7C,WAClD8C,EAAgB7H,EAAa6H,cAAc9C,WAC3C+C,EAAiBF,EAAiBC,EAClCE,EAAa/H,EAAagC,KAAKgG,WAAWjD,WAC1CkD,EACJjI,EAAagC,KAAKqC,uBAClBrE,EAAagC,KAAKqC,sBAAsB4D,WACtCjI,EAAagC,KAAKgG,YAClBhI,EAAagC,KAAKgG,WAAWjD,YAAa,IAAImD,MAAOC,UAAY,KAG/DC,EA7BqB,UA6BK,IAAIF,KACrB,IAAbH,GACAM,eAGFpI,EAAgB,CACd0C,GAAIwE,8CACJlE,UACAV,MAAO,CACLqF,iBACAC,gBACAC,iBACAC,aACAK,uBACAE,UAA8B,IAAnBR,EACXS,UACGN,GACCjI,EAAagC,KAAKgG,WAAWjD,YAAa,IAAImD,MAAOC,UAAY,QAClEnI,EAAawI,cACVxI,EAAawI,YAAYC,eAAeC,KACtC1I,EAAawI,YAAYG,OAAO5D,YAAa,IAAImD,MAAOC,UAAY,IACpEN,EAAgB7H,EAAawI,YAAYG,OAAO5D,aAExD6D,UAAWX,EACXD,WAAYhI,EAAagC,KAAKgG,WAC9BxC,SAAUxF,EAAauF,OACvB/C,UAAWxC,EAAawC,UACxBsB,WAAY9D,EAAagC,KAAK8B,WAC9B0E,YAAaxI,EAAagC,KAAKwG,YAC/BnE,sBAAuBrE,EAAagC,KAAKqC,sBACzCwE,eAAgB7I,EAAagC,KAAK6G,eAClC/D,MAAO9E,EAAagC,KAAK8C,SAI7B+B,QAAQC,IAAI,CACVc,iBACAC,gBACAC,iBACAC,aACAK,uBACAH,YAIF5H,GAAkB,GA1ES,4CAAH,qDA8FxB,OAEEL,GACE,sBAAK8I,UAAU,oBAAf,UAnBkB,WAEtB,IAAMC,EAAc,IAAIb,KAClBc,EAAW,IAAId,KAAqC,IAAhClI,EAAauC,MAAMwF,YAG7C,OAAIgB,EAAcC,GAChBnC,QAAQC,IAAI,qBAEL,cAAC,IAAD,CAAgBkC,SAAUA,KAI5B,iDAAkBhJ,EAAauC,MAAM6F,wBAOrCa,GACD,oDAAqBjJ,EAAauC,MAAMsF,cAAxC,cAA2D7H,EAAauC,MAAMqF,kBAC9E,wBAAQkB,UAAU,yBAAyBI,QAASjH,EAAWkH,SAAUjJ,EAAzE,sBAGCE,GAAkB,uD,6IC1UpB,IAAMoG,EAAgB,uCAAG,WAC9BrD,EACAoC,EACA6D,EACAC,GAJ8B,qDAAA9I,EAAA,yDAK9B+I,EAL8B,+BAKf,WACfC,EAN8B,+BAMjB,eACbC,EAP8B,+BAOZ,SAAC5C,EAAM6C,KACzBC,EAR8B,+BAQf,SAAC9C,EAAM6C,GAAP,OAAe,GAC9BE,EAT8B,uBAWzBpE,EAAOlD,UAXkB,sBAWD,IAAIuH,IAXH,UAaxBC,EAAe,GAEhBF,EAfyB,kCAgBdxG,EAAW2G,mBAAmBP,GAhBhB,QAgB5BI,EAhB4B,0BAmBrBI,GACP,IAAMlG,EAAeuF,EAAeW,GAC9BlH,EAAUwG,EAAWU,GAE3B,GAA4B,IAAxBlG,EAAayC,OACf,iBAGF,IAAI0D,EAAc,IAAIC,cACtBpG,EAAaqG,SAAQ,SAAA9E,GAAW,OAAI4E,EAAYG,IAAI/E,MACpD4E,EAAYI,gBAAkBT,EAAMU,UACpCL,EAAYM,WAAZ,MAAAN,EAAW,CAETzE,EAAOlD,WAFE,mBAGNQ,EAAQ6D,KAAI,SAAA6D,GAAC,OAAIA,EAAElI,gBAGpBQ,EAAQyD,OAAS,GACnB0D,EAAYQ,YAAZ,MAAAR,EAAW,YAAgBnH,IAG7BgH,EAAa5F,KAAK+F,IArBXD,EAAI,EAnBiB,aAmBdA,EAAIX,EAAe9C,QAnBL,mCAmBrByD,GAnBqB,wDAmBaA,IAnBb,yCA2CLxE,EAAOkF,oBAAoBZ,GA3CtB,QA2CxBa,EA3CwB,OA6CxBC,EAAa,GAEfC,EAAmB,CAAEC,YAAY,EAAOd,EAAG,GAC/ClD,QAAQC,IACN,qBACA4D,EAAWpE,OACX,sBACA8C,EAAe9C,QApDa,IAAA/F,EAAA,iBAsDrBwJ,GAtDqB,eAAAxJ,EAAA,0DAuDtBuK,EAAmBC,EAAsB,CAC7C5H,aACA6H,kBAAmBN,EAAWX,MAI7BkB,MAAK,YAAqB,IAAlBrE,EAAiB,EAAjBA,KAAiB,EAAXsE,KACb1B,EAAgB5C,EAAMmD,MAEvBoB,OAAM,SAAAC,GACL1B,EAAagB,EAAWX,GAAIA,GACP,kBAAjBT,IACFsB,EAAiBC,YAAa,EAC9BD,EAAiBb,EAAIA,MAIN,aAAjBT,EAxEwB,0CA0ElBwB,EA1EkB,0DA4ExBjE,QAAQC,IAAI,iBAAZ,OACI8D,EAAiBC,WA7EG,wBA8EtBhE,QAAQC,IAAI,WAAY8D,EAAiBb,GA9EnB,KAiFZa,EAAiBb,EAjFL,UAkFTsB,QAAQC,IAAIX,GAlFH,iCAiFpBhC,OAjFoB,KAkFpBlC,IAlFoB,kEAuF1BkE,EAAY1G,KAAK6G,GAvFS,wDAsDrBf,EAAI,EAtDiB,aAsDdA,EAAIW,EAAWpE,QAtDD,0CAsDrByD,GAtDqB,qGAsDSA,IAtDT,2BA2FT,aAAjBT,EA3F0B,kCA4FtB+B,QAAQC,IAAIX,GA5FU,oBA+FbD,EAAWpE,OA/FE,UA+FiB+E,QAAQC,IAAIX,GA/F7B,8CA+FrBhC,OA/FqB,KA+FMlC,IA/FN,mDAAH,4DAoNhB8E,EAAY,WACvB,OAAO,IAAIrD,MAAOC,UAAY,KAG1BqD,EAAkB,KAEjB,SAAeT,EAAtB,kC,4CAAO,qDAAAxK,EAAA,6DACLyK,EADK,EACLA,kBACA7H,EAFK,EAELA,WAFK,IAGLsI,eAHK,MAGKD,EAHL,EAKCE,EAAiBV,EAAkBW,YACnCC,EAAYL,IACdL,EAAO,EAPN,SAQc/H,EAAW0I,mBAC5BH,EACA,CACEI,eAAe,IAXd,cAQClF,EARD,OAeLC,QAAQC,IAAI,oCAAqCF,GAE7CmF,GAAO,EACX,sBAAC,sBAAAxL,EAAA,yDACSwL,KAAQR,IAAcK,EAAYH,GAD3C,uBAEGtI,EAAW0I,mBAAmBH,EAAgB,CAC5CI,eAAe,IAHpB,SAKSE,EAAM,KALf,gEAAD,GAlBK,oBA2BwBC,EACzBrF,EACA6E,EACAtI,EACA,UACA,GAhCC,WA2BG+I,EA3BH,8BAoCK,IAAIC,MAAM,kDApCf,YAsCCD,EAAaE,IAtCd,uBAuCDvF,QAAQwF,MAAMH,EAAaE,KACrB,IAAID,MAAM,gDAxCf,QA2CHjB,GAAmB,OAAZgB,QAAY,IAAZA,OAAA,EAAAA,EAAchB,OAAQ,EA3C1B,sDA6CHrE,QAAQwF,MAAM,uBAAd,OACI,KAAIZ,QA9CL,uBA+CK,IAAIU,MAAM,kDA/Cf,eAiDCG,EAAiB,KAjDlB,oBAoDOC,EAAoBpJ,EAAY6H,EAAmB,UApD1D,QAmDDsB,EAnDC,OAqDCE,MArDD,+DAuDCF,IAAkBA,EAAeF,IAvDlC,qBAwDGE,EAAeG,KAxDlB,iBAyDU1C,EAAIuC,EAAeG,KAAKnG,OAAS,EAzD3C,aAyD8CyD,GAAK,GAzDnD,sBA0DS2C,EAAOJ,EAAeG,KAAK1C,IACxB4C,WAAW,iBA3DvB,uBA4DW,IAAIR,MACR,uBAAyBO,EAAKE,MAAM,gBAAgBtG,SA7D3D,UAyDwDyD,EAzDxD,8BAkEK,IAAIoC,MAAMU,KAAKC,UAAUR,EAAeF,MAlE7C,yBAsEHL,GAAO,EAtEJ,4BAyELlF,QAAQC,IAAI,UAAWF,EAAM2E,IAAcK,GAzEtC,kBA0EE,CAAEhF,OAAMsE,SA1EV,0E,+BA6EQqB,E,kFAAf,WACEpJ,EACA6G,EACAT,GAHF,uBAAAhJ,EAAA,sEAMsC4C,EAAW4J,iBAE7C5J,EAAW6J,0BARf,cAMEhD,EAAYI,gBANd,OAWQ6C,EAAWjD,EAAYkD,mBAEvBC,EAAkBnD,EAAYoD,WAAWH,GACzCI,EAAqBF,EAAgBG,SAAS,UAE9CC,EAAO,CAACF,EADC,CAAEG,SAAU,SAAUjE,eAfvC,UAmBoBpG,EAAWsK,YAAY,sBAAuBF,GAnBlE,aAmBQG,EAnBR,QAoBUrB,MApBV,uBAqBU,IAAIF,MAAM,mCAAqCuB,EAAIrB,MAAMsB,SArBnE,iCAuBSD,EAAIE,QAvBb,6C,+BA0Be3B,E,kFAAf,WACErF,EACA6E,EACAtI,GAHF,mCAAA5C,EAAA,6DAIEgJ,EAJF,+BAIe,SACbsE,EALF,gCAOM9B,GAAO,EACP+B,EAAS,CACX5C,KAAM,EACN6C,cAAe,EACf3B,IAAK,MAEH4B,EAAQ,EAbd,SAciB,IAAI3C,QAAJ,uCAAY,WAAO4C,EAASC,GAAhB,SAAA3N,EAAA,sDACzB4N,YAAW,WACLpC,IAGJA,GAAO,EACPlF,QAAQC,IAAI,4BACZoH,EAAO,CAAEzC,SAAS,OACjBA,GACH,IACEuC,EAAQ7K,EAAWiL,YACjBxH,GACA,SAACgH,EAAQS,GACPtC,GAAO,EACP+B,EAAS,CACP1B,IAAKwB,EAAOxB,IACZlB,KAAMmD,EAAQnD,KACd6C,cAAe,GAEbH,EAAOxB,KACTvF,QAAQC,IAAI,yBAA0B8G,EAAOxB,KAC7C8B,EAAOJ,KAEPjH,QAAQC,IAAI,yBAA0B8G,GACtCK,EAAQH,MAGZvE,GAEF,MAAO+E,GACPvC,GAAO,EACPlF,QAAQwF,MAAM,oBAAqBzF,EAAM0H,GA/BlB,UAiCjBvC,IAAQ8B,EAjCS,uBAmCvB,sBAAC,4BAAAtN,EAAA,+EAEmC4C,EAAWoL,qBAAqB,CAC9D3H,IAHL,OAES4H,EAFT,OAKGV,EAASU,GAAqBA,EAAkBhC,MAAM,GACjDT,IACE+B,EAEMA,EAAO1B,KAChBvF,QAAQC,IAAI,iBAAkBF,EAAMkH,GACpC/B,GAAO,EACPmC,EAAOJ,EAAO1B,MACJ0B,EAAOC,eAGjBlH,QAAQC,IAAI,wBAAyBF,EAAMkH,GAC3C/B,GAAO,EACPkC,EAAQH,IAJRjH,QAAQC,IAAI,4BAA6BF,EAAMkH,GAN/CjH,QAAQC,IAAI,uBAAwBF,EAAMkH,IARjD,gDAsBQ/B,GACHlF,QAAQC,IAAI,8BAA+BF,EAA3C,MAvBL,wDAAD,GAnCuB,SA8DjBoF,EAAM,KA9DW,iEAAZ,yDAdjB,cAcE8B,EAdF,OAiFM3K,EAAWsL,wBAAwBT,IACrC7K,EAAWuL,wBAAwBV,GACrCjC,GAAO,EACPlF,QAAQC,IAAI,mBAAoBgH,GApFlC,kBAqFSA,GArFT,4C,wBAuFO,SAAS9B,EAAM2C,GACpB,OAAO,IAAItD,SAAQ,SAAA4C,GAAO,OAAIE,WAAWF,EAASU,Q,sEC7crCC,IA/CQ,SAAC,GAAkB,IAAhB5F,EAAe,EAAfA,SAEtB,EAAsCjJ,mBAAS,IAA/C,mBAAO8O,EAAP,KAAoBC,EAApB,KAqCF,OAlCE/H,qBAAU,WACNF,QAAQC,IAAI,uBAGZ,IAAMiI,EAAWC,aAAY,WAC7B,IAAMjG,GAAc,IAAIb,MAAOC,UACzB8G,EAAWjG,EAAWD,EAGtBmG,EAAOC,KAAKC,MAAMH,EAAQ,OAC1BI,EAAQF,KAAKC,MACdH,EAAQ,MAAT,MAEEK,EAAUH,KAAKC,MAAOH,EAAQ,KAAT,KACrBM,EAAUJ,KAAKC,MAAOH,EAAQ,IAAkB,KAGtDH,EAAe,GAAD,OAAII,EAAJ,aAAaG,EAAb,aAAuBC,EAAvB,aAAmCC,EAAnC,MAGVN,EAAW,IACXpI,QAAQC,IAAI,wBACZ0I,cAAcT,MAEf,KAGH,OAAO,WACHA,GACAS,cAAcT,MAGnB,IAGH,sBAAKjG,UAAU,kBAAf,UACE,mBAAGA,UAAU,eAAb,oCACC+F,GAAe,mBAAG/F,UAAU,cAAb,0BAAiC+F,U,+RC7CxC,G,OAAA,IAA0B,0C,iBCMnCY,EAAiB,cACjBC,EAAY,8BAA0BD,GAoF7BE,EAlFH,WAEV,MAA0C5P,mBAAS,MAAnD,mBAAOD,EAAP,KAAsB8P,EAAtB,KAGMC,EAAwB,uCAAG,gCAAAtP,EAAA,oEAEV8G,SAAXC,EAFqB,EAErBA,QAFqB,qBAKvBA,EAAOwI,UALgB,wBAMzBjJ,QAAQC,IAAI,yBANa,SASFQ,EAAOyI,QAAQ,CAAEC,eAAe,IAT9B,OASnBC,EATmB,OAUzBpJ,QAAQC,IACN,6BACAmJ,EAAS5N,UAAUiL,YAErBsC,EAAiBK,EAAS5N,UAAUiL,YAdX,gCAiB3B4C,MAAM,8DAjBqB,0DAoB7BrJ,QAAQwF,MAAR,MApB6B,0DAAH,qDAwBxB8D,EAAa,uCAAG,gCAAA5P,EAAA,2DACD8G,SAAXC,EADY,EACZA,QADY,gCAIKA,EAAOyI,UAJZ,OAIZE,EAJY,OAKlBpJ,QAAQC,IAAI,6BAA8BmJ,EAAS5N,UAAUiL,YAC7DsC,EAAiBK,EAAS5N,UAAUiL,YANlB,2CAAH,qDA6BnB,OARAvG,qBAAU,WACR,IAAMqJ,EAAM,uCAAG,sBAAA7P,EAAA,sEACPsP,IADO,2CAAH,qDAIZ,OADAxI,OAAOgJ,iBAAiB,OAAQD,GACzB,kBAAM/I,OAAOiJ,oBAAoB,OAAQF,MAC/C,IAGD,qBAAKtH,UAAU,MAAf,SACE,sBAAKA,UAAU,YAAf,UACE,sBAAKA,UAAU,mBAAf,UACE,mBAAGA,UAAU,SAAb,mDACA,mBAAGA,UAAU,WAAb,8CACEhJ,GAvBR,wBACEgJ,UAAU,mCACVI,QAASiH,EAFX,kCA0BKrQ,GAAiB,cAACD,EAAA,EAAD,CAAcC,cAAeuH,OAAOC,SACtD,sBAAKwB,UAAU,mBAAf,UACE,qBAAKyH,IAAI,eAAezH,UAAU,eAAe0H,IAAKC,IACtD,mBACE3H,UAAU,cACV4H,KAAMhB,EACNiB,OAAO,SACPC,IAAI,aAJN,6BAKenB,cC/EzBoB,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,U,sUCEpBnQ,G,KAAsB,IAAInB,IAAKc,UACnC,gDAGIQ,EAA4B,IAAItB,IAAKc,UACzC,+CAGIsB,EAA0C,IAAIpC,IAAKc,UACvD,gDAGI0D,EAAQ,IAAI+M,IAAYzQ,UAC5B,+CAkCI2B,GAvBiB,IAAI+O,KAAKC,aAAa,QAAS,CACpDC,MAAO,UACPC,sBAAuB,EACvBC,sBAAuB,IAoBN,uCAAG,WAAOvQ,EAAMwQ,GAAb,SAAAjR,EAAA,sEACP2Q,IAAYzQ,UAAUC,mBACjC,CAAC8Q,EAAM3Q,WAAYe,IAAiBf,WAAYG,EAAKH,YACrDkB,GAHkB,mFAAH,yDAObqC,EAAgB,uCAAG,WAAOJ,GAAP,SAAAzD,EAAA,sEACV2Q,IAAYzQ,UAAUC,mBACjC,CAACsD,EAAkBnD,WAAYF,EAAOC,KAAK,WAC3CuD,GAHqB,mFAAH,sDAOhBJ,EAAe,uCAAG,WAAOwB,EAAQvB,GAAf,SAAAzD,EAAA,sEACT2Q,IAAYzQ,UAAUC,mBACjC,CACE6E,EAAO1E,WACPF,EAAOC,KAAK,WACZD,EAAOC,KAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAClCoD,EAAkBnD,YAEpBsD,GARoB,mFAAH,0D","file":"static/js/main.f6599724.chunk.js","sourcesContent":["import React, {useState, useEffect} from 'react';\r\nimport { Connection, PublicKey } from '@solana/web3.js';\r\nimport { Program, Provider, web3 } from '@project-serum/anchor';\r\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\r\nimport { sendTransactions } from './connection';\r\nimport { programs } from '@metaplex/js';\r\nimport './CandyMachine.css';\r\nimport CountdownTimer from '../CountdownTimer';\r\nimport {\r\n  candyMachineProgram,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  getAtaForMint,\r\n  getNetworkExpire,\r\n  getNetworkToken,\r\n  CIVIC\r\n} from './helpers';\r\n\r\nconst { SystemProgram } = web3;\r\nconst opts = {\r\n  preflightCommitment: 'processed',\r\n};\r\n\r\nconst CandyMachine = ({ walletAddress }) => {\r\n  // Add state property inside your component like this\r\n  const [candyMachine, setCandyMachine] = useState(null);\r\n  const [isMinting, setIsMinting] = useState(false);\r\n  const [isLoadingMints, setIsLoadingMints] = useState(false);\r\n\r\n  const getCandyMachineCreator = async (candyMachine) => {\r\n    const candyMachineID = new PublicKey(candyMachine);\r\n    return await web3.PublicKey.findProgramAddress(\r\n        [Buffer.from('candy_machine'), candyMachineID.toBuffer()],\r\n        candyMachineProgram,\r\n    );\r\n  };\r\n\r\n  const getMetadata = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getMasterEdition = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from('metadata'),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n          Buffer.from('edition'),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const createAssociatedTokenAccountInstruction = (\r\n    associatedTokenAddress,\r\n    payer,\r\n    walletAddress,\r\n    splTokenMintAddress\r\n  ) => {\r\n    const keys = [\r\n      { pubkey: payer, isSigner: true, isWritable: true },\r\n      { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n      { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n      { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SystemProgram.programId,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SYSVAR_RENT_PUBKEY,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n    ];\r\n    return new web3.TransactionInstruction({\r\n      keys,\r\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n      data: Buffer.from([]),\r\n    });\r\n  };\r\n\r\n  const mintToken = async () => {\r\n    setIsMinting(true);\r\n\r\n    const mint = web3.Keypair.generate();\r\n\r\n    const userTokenAccountAddress = (\r\n      await getAtaForMint(mint.publicKey, walletAddress.publicKey)\r\n    )[0];\r\n  \r\n    const userPayingAccountAddress = candyMachine.state.tokenMint\r\n      ? (await getAtaForMint(candyMachine.state.tokenMint, walletAddress.publicKey))[0]\r\n      : walletAddress.publicKey;\r\n  \r\n    const candyMachineAddress = candyMachine.id;\r\n    const remainingAccounts = [];\r\n    const signers = [mint];\r\n    const cleanupInstructions = [];\r\n    const instructions = [\r\n      web3.SystemProgram.createAccount({\r\n        fromPubkey: walletAddress.publicKey,\r\n        newAccountPubkey: mint.publicKey,\r\n        space: MintLayout.span,\r\n        lamports:\r\n          await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\r\n            MintLayout.span,\r\n          ),\r\n        programId: TOKEN_PROGRAM_ID,\r\n      }),\r\n      Token.createInitMintInstruction(\r\n        TOKEN_PROGRAM_ID,\r\n        mint.publicKey,\r\n        0,\r\n        walletAddress.publicKey,\r\n        walletAddress.publicKey,\r\n      ),\r\n      createAssociatedTokenAccountInstruction(\r\n        userTokenAccountAddress,\r\n        walletAddress.publicKey,\r\n        walletAddress.publicKey,\r\n        mint.publicKey,\r\n      ),\r\n      Token.createMintToInstruction(\r\n        TOKEN_PROGRAM_ID,\r\n        mint.publicKey,\r\n        userTokenAccountAddress,\r\n        walletAddress.publicKey,\r\n        [],\r\n        1,\r\n      ),\r\n    ];\r\n  \r\n    if (candyMachine.state.gatekeeper) {\r\n      remainingAccounts.push({\r\n        pubkey: (\r\n          await getNetworkToken(\r\n            walletAddress.publicKey,\r\n            candyMachine.state.gatekeeper.gatekeeperNetwork,\r\n          )\r\n        )[0],\r\n        isWritable: true,\r\n        isSigner: false,\r\n      });\r\n      if (candyMachine.state.gatekeeper.expireOnUse) {\r\n        remainingAccounts.push({\r\n          pubkey: CIVIC,\r\n          isWritable: false,\r\n          isSigner: false,\r\n        });\r\n        remainingAccounts.push({\r\n          pubkey: (\r\n            await getNetworkExpire(\r\n              candyMachine.state.gatekeeper.gatekeeperNetwork,\r\n            )\r\n          )[0],\r\n          isWritable: false,\r\n          isSigner: false,\r\n        });\r\n      }\r\n    }\r\n    if (candyMachine.state.whitelistMintSettings) {\r\n      const mint = new web3.PublicKey(\r\n        candyMachine.state.whitelistMintSettings.mint,\r\n      );\r\n  \r\n      const whitelistToken = (await getAtaForMint(mint, walletAddress.publicKey))[0];\r\n      remainingAccounts.push({\r\n        pubkey: whitelistToken,\r\n        isWritable: true,\r\n        isSigner: false,\r\n      });\r\n  \r\n      if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\r\n        const whitelistBurnAuthority = web3.Keypair.generate();\r\n  \r\n        remainingAccounts.push({\r\n          pubkey: mint,\r\n          isWritable: true,\r\n          isSigner: false,\r\n        });\r\n        remainingAccounts.push({\r\n          pubkey: whitelistBurnAuthority.publicKey,\r\n          isWritable: false,\r\n          isSigner: true,\r\n        });\r\n        signers.push(whitelistBurnAuthority);\r\n        const exists =\r\n          await candyMachine.program.provider.connection.getAccountInfo(\r\n            whitelistToken,\r\n          );\r\n        if (exists) {\r\n          instructions.push(\r\n            Token.createApproveInstruction(\r\n              TOKEN_PROGRAM_ID,\r\n              whitelistToken,\r\n              whitelistBurnAuthority.publicKey,\r\n              walletAddress.publicKey,\r\n              [],\r\n              1,\r\n            ),\r\n          );\r\n          cleanupInstructions.push(\r\n            Token.createRevokeInstruction(\r\n              TOKEN_PROGRAM_ID,\r\n              whitelistToken,\r\n              walletAddress.publicKey,\r\n              [],\r\n            ),\r\n          );\r\n        }\r\n      }\r\n    }\r\n  \r\n    if (candyMachine.state.tokenMint) {\r\n      const transferAuthority = web3.Keypair.generate();\r\n  \r\n      signers.push(transferAuthority);\r\n      remainingAccounts.push({\r\n        pubkey: userPayingAccountAddress,\r\n        isWritable: true,\r\n        isSigner: false,\r\n      });\r\n      remainingAccounts.push({\r\n        pubkey: transferAuthority.publicKey,\r\n        isWritable: false,\r\n        isSigner: true,\r\n      });\r\n  \r\n      instructions.push(\r\n        Token.createApproveInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          userPayingAccountAddress,\r\n          transferAuthority.publicKey,\r\n          walletAddress.publicKey,\r\n          [],\r\n          candyMachine.state.price.toNumber(),\r\n        ),\r\n      );\r\n      cleanupInstructions.push(\r\n        Token.createRevokeInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          userPayingAccountAddress,\r\n          walletAddress.publicKey,\r\n          [],\r\n        ),\r\n      );\r\n    }\r\n    const metadataAddress = await getMetadata(mint.publicKey);\r\n    const masterEdition = await getMasterEdition(mint.publicKey);\r\n  \r\n    const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\r\n      candyMachineAddress,\r\n    );\r\n  \r\n    instructions.push(\r\n      await candyMachine.program.instruction.mintNft(creatorBump, {\r\n        accounts: {\r\n          candyMachine: candyMachineAddress,\r\n          candyMachineCreator,\r\n          payer: walletAddress.publicKey,\r\n          wallet: candyMachine.state.treasury,\r\n          mint: mint.publicKey,\r\n          metadata: metadataAddress,\r\n          masterEdition,\r\n          mintAuthority: walletAddress.publicKey,\r\n          updateAuthority: walletAddress.publicKey,\r\n          tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n          tokenProgram: TOKEN_PROGRAM_ID,\r\n          systemProgram: SystemProgram.programId,\r\n          rent: web3.SYSVAR_RENT_PUBKEY,\r\n          clock: web3.SYSVAR_CLOCK_PUBKEY,\r\n          recentBlockhashes: web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\r\n          instructionSysvarAccount: web3.SYSVAR_INSTRUCTIONS_PUBKEY,\r\n        },\r\n        remainingAccounts:\r\n          remainingAccounts.length > 0 ? remainingAccounts : undefined,\r\n      }),\r\n    );\r\n  \r\n    try {\r\n      setIsMinting(false);\r\n      return (\r\n        await sendTransactions(\r\n          candyMachine.program.provider.connection,\r\n          candyMachine.program.provider.wallet,\r\n          [instructions, cleanupInstructions],\r\n          [signers, []],\r\n        )\r\n      ).txs.map(t => t.txid);\r\n    } catch (e) {\r\n      console.log(e);\r\n    }\r\n    setIsMinting(false);\r\n    return [];\r\n  };\r\n\r\n  useEffect(() => {\r\n    getCandyMachineState();\r\n  }, []);\r\n\r\n  const getProvider = () => {\r\n    const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n    // Create a new connection object\r\n    const connection = new Connection(rpcHost);\r\n    \r\n    // Create a new Solana provider object\r\n    const provider = new Provider(\r\n      connection,\r\n      window.solana,\r\n      opts.preflightCommitment\r\n    );\r\n  \r\n    return provider;\r\n  };\r\n\r\n  // Declare getCandyMachineState as an async method\r\nconst getCandyMachineState = async () => {\r\n  // Set loading flag.\r\n  setIsLoadingMints(true);\r\n\r\n  const provider = getProvider();\r\n  \r\n  // Get metadata about your deployed candy machine program\r\n  const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n\r\n  // Create a program that you can call\r\n  const program = new Program(idl, candyMachineProgram, provider);\r\n\r\n  // Fetch the metadata from your candy machine\r\n  const candyMachine = await program.account.candyMachine.fetch(\r\n    process.env.REACT_APP_CANDY_MACHINE_ID\r\n  );\r\n  \r\n  // Parse out all our metadata and log it out\r\n  const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\r\n  const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\r\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n  const goLiveData = candyMachine.data.goLiveDate.toNumber();\r\n  const presale =\r\n    candyMachine.data.whitelistMintSettings &&\r\n    candyMachine.data.whitelistMintSettings.presale &&\r\n    (!candyMachine.data.goLiveDate ||\r\n      candyMachine.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\r\n  \r\n  // We will be using this later in our UI so let's generate this now\r\n  const goLiveDateTimeString = `${new Date(\r\n    goLiveData * 1000\r\n  ).toGMTString()}`\r\n\r\n  // Render State\r\n  setCandyMachine({\r\n    id: process.env.REACT_APP_CANDY_MACHINE_ID,\r\n    program,\r\n    state: {\r\n      itemsAvailable,\r\n      itemsRedeemed,\r\n      itemsRemaining,\r\n      goLiveData,\r\n      goLiveDateTimeString,\r\n      isSoldOut: itemsRemaining === 0,\r\n      isActive:\r\n        (presale ||\r\n          candyMachine.data.goLiveDate.toNumber() < new Date().getTime() / 1000) &&\r\n        (candyMachine.endSettings\r\n          ? candyMachine.endSettings.endSettingType.date\r\n            ? candyMachine.endSettings.number.toNumber() > new Date().getTime() / 1000\r\n            : itemsRedeemed < candyMachine.endSettings.number.toNumber()\r\n          : true),\r\n      isPresale: presale,\r\n      goLiveDate: candyMachine.data.goLiveDate,\r\n      treasury: candyMachine.wallet,\r\n      tokenMint: candyMachine.tokenMint,\r\n      gatekeeper: candyMachine.data.gatekeeper,\r\n      endSettings: candyMachine.data.endSettings,\r\n      whitelistMintSettings: candyMachine.data.whitelistMintSettings,\r\n      hiddenSettings: candyMachine.data.hiddenSettings,\r\n      price: candyMachine.data.price,\r\n    },\r\n  });\r\n\r\n  console.log({\r\n    itemsAvailable,\r\n    itemsRedeemed,\r\n    itemsRemaining,\r\n    goLiveData,\r\n    goLiveDateTimeString,\r\n    presale,\r\n  });\r\n\r\n  // Remove loading flag.\r\n  setIsLoadingMints(false);\r\n};\r\n\r\n// Create render function\r\nconst renderDropTimer = () => {\r\n  // Get the current date and dropDate in a JavaScript Date object\r\n  const currentDate = new Date();\r\n  const dropDate = new Date(candyMachine.state.goLiveData * 1000);\r\n\r\n  // If currentDate is before dropDate, render our Countdown component\r\n  if (currentDate < dropDate) {\r\n    console.log('Before drop date!');\r\n    // Don't forget to pass over your dropDate!\r\n    return <CountdownTimer dropDate={dropDate} />;\r\n  }\r\n\r\n  // Else let's just return the current drop date\r\n  return <p>{`Drop Date: ${candyMachine.state.goLiveDateTimeString}`}</p>;\r\n};\r\n\r\n  return (\r\n    // Only show this if machineStats is available\r\n    candyMachine && (\r\n      <div className=\"machine-container\">\r\n        {renderDropTimer()}\r\n        <p>{`Items Minted: ${candyMachine.state.itemsRedeemed} / ${candyMachine.state.itemsAvailable}`}</p>\r\n        <button className=\"cta-button mint-button\" onClick={mintToken} disabled={isMinting}>\r\n            Mint NFT\r\n        </button>\r\n        {isLoadingMints && <p>LOADING MINTS...</p>}\r\n      </div>\r\n    )\r\n  );\r\n};\r\n\r\nexport default CandyMachine;\r\n","import { Transaction } from '@solana/web3.js';\r\n\r\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\r\n\r\nexport const getErrorForTransaction = async (\r\n  connection,\r\n  txid\r\n) => {\r\n  // wait for all confirmation before geting transaction\r\n  await connection.confirmTransaction(txid, 'max');\r\n\r\n  const tx = await connection.getParsedConfirmedTransaction(txid);\r\n\r\n  const errors = [];\r\n  if (tx?.meta && tx.meta.logMessages) {\r\n    tx.meta.logMessages.forEach(log => {\r\n      const regex = /Error: (.*)/gm;\r\n      let m;\r\n      while ((m = regex.exec(log)) !== null) {\r\n        // This is necessary to avoid infinite loops with zero-width matches\r\n        if (m.index === regex.lastIndex) {\r\n          regex.lastIndex++;\r\n        }\r\n\r\n        if (m.length > 1) {\r\n          errors.push(m[1]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  return errors;\r\n};\r\n\r\n\r\nexport async function sendTransactionsWithManualRetry(\r\n  connection,\r\n  wallet,\r\n  instructions,\r\n  signers,\r\n){\r\n  let stopPoint = 0;\r\n  let tries = 0;\r\n  let lastInstructionsLength = null;\r\n  let toRemoveSigners = {};\r\n  instructions = instructions.filter((instr, i) => {\r\n    if (instr.length > 0) {\r\n      return true;\r\n    } else {\r\n      toRemoveSigners[i] = true;\r\n      return false;\r\n    }\r\n  });\r\n  let ids = [];\r\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\r\n\r\n  while (stopPoint < instructions.length && tries < 3) {\r\n    instructions = instructions.slice(stopPoint, instructions.length);\r\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\r\n\r\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\r\n    else tries = 0;\r\n\r\n    try {\r\n      if (instructions.length === 1) {\r\n        const id = await sendTransactionWithRetry(\r\n          connection,\r\n          wallet,\r\n          instructions[0],\r\n          filteredSigners[0],\r\n          'single',\r\n        );\r\n        ids.push(id.txid);\r\n        stopPoint = 1;\r\n      } else {\r\n        const { txs } = await sendTransactions(\r\n          connection,\r\n          wallet,\r\n          instructions,\r\n          filteredSigners,\r\n          'StopOnFailure',\r\n          'single',\r\n        );\r\n        ids = ids.concat(txs.map(t => t.txid));\r\n      }\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n    console.log(\r\n      'Died on ',\r\n      stopPoint,\r\n      'retrying from instruction',\r\n      instructions[stopPoint],\r\n      'instructions length is',\r\n      instructions.length,\r\n    );\r\n    lastInstructionsLength = instructions.length;\r\n  }\r\n\r\n  return ids;\r\n}\r\n\r\nexport const sendTransactions = async (\r\n  connection,\r\n  wallet,\r\n  instructionSet,\r\n  signersSet,\r\n  sequenceType = 'Parallel',\r\n  commitment = 'singleGossip',\r\n  successCallback = (txid, ind) => {},\r\n  failCallback = (txid, ind) => false,\r\n  block,\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  const unsignedTxns = [];\r\n\r\n  if (!block) {\r\n    block = await connection.getRecentBlockhash(commitment);\r\n  }\r\n\r\n  for (let i = 0; i < instructionSet.length; i++) {\r\n    const instructions = instructionSet[i];\r\n    const signers = signersSet[i];\r\n\r\n    if (instructions.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    let transaction = new Transaction();\r\n    instructions.forEach(instruction => transaction.add(instruction));\r\n    transaction.recentBlockhash = block.blockhash;\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n\r\n    if (signers.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n\r\n    unsignedTxns.push(transaction);\r\n  }\r\n\r\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\r\n\r\n  const pendingTxns= [];\r\n\r\n  let breakEarlyObject = { breakEarly: false, i: 0 };\r\n  console.log(\r\n    'Signed txns length',\r\n    signedTxns.length,\r\n    'vs handed in length',\r\n    instructionSet.length,\r\n  );\r\n  for (let i = 0; i < signedTxns.length; i++) {\r\n    const signedTxnPromise = sendSignedTransaction({\r\n      connection,\r\n      signedTransaction: signedTxns[i],\r\n    });\r\n\r\n    signedTxnPromise\r\n      .then(({ txid, slot }) => {\r\n        successCallback(txid, i);\r\n      })\r\n      .catch(reason => {\r\n        failCallback(signedTxns[i], i);\r\n        if (sequenceType === 'StopOnFailure') {\r\n          breakEarlyObject.breakEarly = true;\r\n          breakEarlyObject.i = i;\r\n        }\r\n      });\r\n\r\n    if (sequenceType !== 'Parallel') {\r\n      try {\r\n        await signedTxnPromise;\r\n      } catch (e) {\r\n        console.log('Caught failure', e);\r\n        if (breakEarlyObject.breakEarly) {\r\n          console.log('Died on ', breakEarlyObject.i);\r\n          // Return the txn we failed on by index\r\n          return {\r\n            number: breakEarlyObject.i,\r\n            txs: await Promise.all(pendingTxns),\r\n          };\r\n        }\r\n      }\r\n    } else {\r\n      pendingTxns.push(signedTxnPromise);\r\n    }\r\n  }\r\n\r\n  if (sequenceType !== 'Parallel') {\r\n    await Promise.all(pendingTxns);\r\n  }\r\n\r\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\r\n};\r\n\r\nexport const sendTransaction = async (\r\n  connection,\r\n  wallet,\r\n  instructions,\r\n  signers,\r\n  awaitConfirmation = true,\r\n  commitment = 'singleGossip',\r\n  includesFeePayer = false,\r\n  block,\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction = new Transaction();\r\n  instructions.forEach(instruction => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map(s => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  if (!includesFeePayer) {\r\n    transaction = await wallet.signTransaction(transaction);\r\n  }\r\n\r\n  const rawTransaction = transaction.serialize();\r\n  let options = {\r\n    skipPreflight: true,\r\n    commitment,\r\n  };\r\n\r\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\r\n  let slot = 0;\r\n\r\n  if (awaitConfirmation) {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      DEFAULT_TIMEOUT,\r\n      connection,\r\n      commitment,\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n    slot = confirmation?.slot || 0;\r\n\r\n    if (confirmation?.err) {\r\n      const errors = await getErrorForTransaction(connection, txid);\r\n\r\n      console.log(errors);\r\n      throw new Error(`Raw transaction ${txid} failed`);\r\n    }\r\n  }\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport const sendTransactionWithRetry = async (\r\n  connection,\r\n  wallet,\r\n  instructions,\r\n  signers,\r\n  commitment = 'singleGossip',\r\n  includesFeePayer = false,\r\n  block,\r\n  beforeSend,\r\n) => {\r\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\r\n\r\n  let transaction = new Transaction();\r\n  instructions.forEach(instruction => transaction.add(instruction));\r\n  transaction.recentBlockhash = (\r\n    block || (await connection.getRecentBlockhash(commitment))\r\n  ).blockhash;\r\n\r\n  if (includesFeePayer) {\r\n    transaction.setSigners(...signers.map(s => s.publicKey));\r\n  } else {\r\n    transaction.setSigners(\r\n      // fee payed by the wallet owner\r\n      wallet.publicKey,\r\n      ...signers.map(s => s.publicKey),\r\n    );\r\n  }\r\n\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  if (!includesFeePayer) {\r\n    transaction = await wallet.signTransaction(transaction);\r\n  }\r\n\r\n  if (beforeSend) {\r\n    beforeSend();\r\n  }\r\n\r\n  const { txid, slot } = await sendSignedTransaction({\r\n    connection,\r\n    signedTransaction: transaction,\r\n  });\r\n\r\n  return { txid, slot };\r\n};\r\n\r\nexport const getUnixTs = () => {\r\n  return new Date().getTime() / 1000;\r\n};\r\n\r\nconst DEFAULT_TIMEOUT = 15000;\r\n\r\nexport async function sendSignedTransaction({\r\n  signedTransaction,\r\n  connection,\r\n  timeout = DEFAULT_TIMEOUT,\r\n}) {\r\n  const rawTransaction = signedTransaction.serialize();\r\n  const startTime = getUnixTs();\r\n  let slot = 0;\r\n  const txid = await connection.sendRawTransaction(\r\n    rawTransaction,\r\n    {\r\n      skipPreflight: true,\r\n    },\r\n  );\r\n\r\n  console.log('Started awaiting confirmation for', txid);\r\n\r\n  let done = false;\r\n  (async () => {\r\n    while (!done && getUnixTs() - startTime < timeout) {\r\n      connection.sendRawTransaction(rawTransaction, {\r\n        skipPreflight: true,\r\n      });\r\n      await sleep(500);\r\n    }\r\n  })();\r\n  try {\r\n    const confirmation = await awaitTransactionSignatureConfirmation(\r\n      txid,\r\n      timeout,\r\n      connection,\r\n      'recent',\r\n      true,\r\n    );\r\n\r\n    if (!confirmation)\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n\r\n    if (confirmation.err) {\r\n      console.error(confirmation.err);\r\n      throw new Error('Transaction failed: Custom instruction error');\r\n    }\r\n\r\n    slot = confirmation?.slot || 0;\r\n  } catch (err) {\r\n    console.error('Timeout Error caught', err);\r\n    if (err.timeout) {\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n    }\r\n    let simulateResult = null;\r\n    try {\r\n      simulateResult = (\r\n        await simulateTransaction(connection, signedTransaction, 'single')\r\n      ).value;\r\n    } catch (e) {}\r\n    if (simulateResult && simulateResult.err) {\r\n      if (simulateResult.logs) {\r\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n          const line = simulateResult.logs[i];\r\n          if (line.startsWith('Program log: ')) {\r\n            throw new Error(\r\n              'Transaction failed: ' + line.slice('Program log: '.length),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      throw new Error(JSON.stringify(simulateResult.err));\r\n    }\r\n    // throw new Error('Transaction failed');\r\n  } finally {\r\n    done = true;\r\n  }\r\n\r\n  console.log('Latency', txid, getUnixTs() - startTime);\r\n  return { txid, slot };\r\n}\r\n\r\nasync function simulateTransaction(\r\n  connection,\r\n  transaction,\r\n  commitment,\r\n) {\r\n  // @ts-ignore\r\n  transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching,\r\n  );\r\n\r\n  const signData = transaction.serializeMessage();\r\n  // @ts-ignore\r\n  const wireTransaction = transaction._serialize(signData);\r\n  const encodedTransaction = wireTransaction.toString('base64');\r\n  const config = { encoding: 'base64', commitment };\r\n  const args = [encodedTransaction, config];\r\n\r\n  // @ts-ignore\r\n  const res = await connection._rpcRequest('simulateTransaction', args);\r\n  if (res.error) {\r\n    throw new Error('failed to simulate transaction: ' + res.error.message);\r\n  }\r\n  return res.result;\r\n}\r\n\r\nasync function awaitTransactionSignatureConfirmation(\r\n  txid,\r\n  timeout,\r\n  connection,\r\n  commitment = 'recent',\r\n  queryStatus = false,\r\n){\r\n  let done = false;\r\n  let status = {\r\n    slot: 0,\r\n    confirmations: 0,\r\n    err: null,\r\n  };\r\n  let subId = 0;\r\n  status = await new Promise(async (resolve, reject) => {\r\n    setTimeout(() => {\r\n      if (done) {\r\n        return;\r\n      }\r\n      done = true;\r\n      console.log('Rejecting for timeout...');\r\n      reject({ timeout: true });\r\n    }, timeout);\r\n    try {\r\n      subId = connection.onSignature(\r\n        txid,\r\n        (result, context) => {\r\n          done = true;\r\n          status = {\r\n            err: result.err,\r\n            slot: context.slot,\r\n            confirmations: 0,\r\n          };\r\n          if (result.err) {\r\n            console.log('Rejected via websocket', result.err);\r\n            reject(status);\r\n          } else {\r\n            console.log('Resolved via websocket', result);\r\n            resolve(status);\r\n          }\r\n        },\r\n        commitment,\r\n      );\r\n    } catch (e) {\r\n      done = true;\r\n      console.error('WS error in setup', txid, e);\r\n    }\r\n    while (!done && queryStatus) {\r\n      // eslint-disable-next-line no-loop-func\r\n      (async () => {\r\n        try {\r\n          const signatureStatuses = await connection.getSignatureStatuses([\r\n            txid,\r\n          ]);\r\n          status = signatureStatuses && signatureStatuses.value[0];\r\n          if (!done) {\r\n            if (!status) {\r\n              console.log('REST null result for', txid, status);\r\n            } else if (status.err) {\r\n              console.log('REST error for', txid, status);\r\n              done = true;\r\n              reject(status.err);\r\n            } else if (!status.confirmations) {\r\n              console.log('REST no confirmations for', txid, status);\r\n            } else {\r\n              console.log('REST confirmation for', txid, status);\r\n              done = true;\r\n              resolve(status);\r\n            }\r\n          }\r\n        } catch (e) {\r\n          if (!done) {\r\n            console.log('REST connection error: txid', txid, e);\r\n          }\r\n        }\r\n      })();\r\n      await sleep(2000);\r\n    }\r\n  });\r\n\r\n  //@ts-ignore\r\n  if (connection._signatureSubscriptions[subId])\r\n    connection.removeSignatureListener(subId);\r\n  done = true;\r\n  console.log('Returning status', status);\r\n  return status;\r\n}\r\nexport function sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import React, { useEffect, useState } from 'react';\r\nimport './CountdownTimer.css';\r\n\r\nconst CountdownTimer = ({ dropDate }) => {\r\n    // State\r\n    const [timerString, setTimerString] = useState('');\r\n\r\n    // Our useEffect will run on component load\r\n    useEffect(() => {\r\n        console.log('Setting interval...');\r\n\r\n        // Use setInterval to run this piece of code every second\r\n        const interval = setInterval(() => {\r\n        const currentDate = new Date().getTime();\r\n        const distance = dropDate - currentDate;\r\n\r\n        // Here it's as easy as doing some time math to get the different properties\r\n        const days = Math.floor(distance / (1000 * 60 * 60 * 24));\r\n        const hours = Math.floor(\r\n            (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)\r\n        );\r\n        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\r\n        const seconds = Math.floor((distance % (1000 * 60)) / 1000);\r\n\r\n        // We have our desired output, set it in state!\r\n        setTimerString(`${days}d ${hours}h ${minutes}m ${seconds}s`);\r\n\r\n        // If our distance passes zero this means that it's drop time!\r\n        if (distance < 0) {\r\n            console.log('Clearing interval...');\r\n            clearInterval(interval);\r\n        }\r\n        }, 1000);\r\n\r\n        // Anytime our component unmounts let's clean up our interval\r\n        return () => {\r\n        if (interval) {\r\n            clearInterval(interval);\r\n        }\r\n        };\r\n    }, []);\r\n\r\n  return (\r\n    <div className=\"timer-container\">\r\n      <p className=\"timer-header\">Candy Drop Starting In</p>\r\n      {timerString && <p className=\"timer-value\">{`‚è∞ ${timerString}`}</p>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CountdownTimer;","export default __webpack_public_path__ + \"static/media/twitter-logo.4844b78f.svg\";","import React, {useEffect, useState} from 'react';\r\nimport './App.css';\r\nimport twitterLogo from './assets/twitter-logo.svg';\r\nimport CandyMachine from './CandyMachine';\r\n\r\n// Constants\r\nconst TWITTER_HANDLE = '_buildspace';\r\nconst TWITTER_LINK = `https://twitter.com/${TWITTER_HANDLE}`;\r\n\r\nconst App = () => {\r\n  // State\r\n  const [walletAddress, setWalletAddress] = useState(null);\r\n\r\n  // Check if wallet is connected\r\n  const checkIfWalletIsConnected = async () => {\r\n    try {\r\n      const { solana } = window;\r\n\r\n      if (solana) {\r\n        if (solana.isPhantom) {\r\n          console.log('Phantom wallet found!');\r\n\r\n          // Connect directly if we're authorized to acess the user's wallet\r\n          const response = await solana.connect({ onlyIfTrusted: true });\r\n          console.log(\r\n            'Connected with Public Key:',\r\n            response.publicKey.toString()\r\n          );\r\n          setWalletAddress(response.publicKey.toString());\r\n        }\r\n      } else {\r\n        alert('Solana object not found! Get a Phantom Wallet üëª');\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  };\r\n\r\n  const connectWallet = async () => {\r\n    const { solana } = window;\r\n\r\n    if (solana) {\r\n      const response = await solana.connect();\r\n      console.log('Connected with Public Key:', response.publicKey.toString());\r\n      setWalletAddress(response.publicKey.toString());\r\n    }\r\n  };\r\n\r\n  // Render connect to wallet button if user hasn't connected\r\n  const renderNotConnectedContainer = () => (\r\n    <button\r\n      className=\"cta-button connect-wallet-button\"\r\n      onClick={connectWallet}\r\n    >\r\n      Connect to Wallet\r\n    </button>\r\n  );\r\n\r\n  // When component first mounts, check if we have connected wallet\r\n  useEffect(() => {\r\n    const onLoad = async () => {\r\n      await checkIfWalletIsConnected();\r\n    };\r\n    window.addEventListener('load', onLoad);\r\n    return () => window.removeEventListener('load', onLoad);\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"container\">\r\n        <div className=\"header-container\">\r\n          <p className=\"header\">‚öîÔ∏è Attack on Titan NFT Drop</p>\r\n          <p className=\"sub-text\">NFT drop machine with fair mint</p>\r\n          {!walletAddress && renderNotConnectedContainer()}\r\n        </div>\r\n        {/* Check for walletAddress and then pass in walletAddress */}\r\n        {walletAddress && <CandyMachine walletAddress={window.solana} />}\r\n        <div className=\"footer-container\">\r\n          <img alt=\"Twitter Logo\" className=\"twitter-logo\" src={twitterLogo} />\r\n          <a\r\n            className=\"footer-text\"\r\n            href={TWITTER_LINK}\r\n            target=\"_blank\"\r\n            rel=\"noreferrer\"\r\n          >{`built on @${TWITTER_HANDLE}`}</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n","import { web3 } from '@project-serum/anchor';\r\nimport * as anchor from '@project-serum/anchor';\r\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\r\nimport { SystemProgram } from '@solana/web3.js';\r\nimport {\r\n  LAMPORTS_PER_SOL,\r\n  SYSVAR_RENT_PUBKEY,\r\n  TransactionInstruction,\r\n} from '@solana/web3.js';\r\n\r\n// CLI Properties Given to us\r\nconst candyMachineProgram = new web3.PublicKey(\r\n  'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ'\r\n);\r\n\r\nconst TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\r\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'\r\n);\r\n\r\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new web3.PublicKey(\r\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\r\n);\r\n\r\nconst CIVIC = new anchor.web3.PublicKey(\r\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\r\n);\r\n\r\nconst toDate = (value) => {\r\n  if (!value) {\r\n    return;\r\n  }\r\n\r\n  return new Date(value.toNumber() * 1000);\r\n};\r\n\r\nconst numberFormater = new Intl.NumberFormat('en-US', {\r\n  style: 'decimal',\r\n  minimumFractionDigits: 2,\r\n  maximumFractionDigits: 2,\r\n});\r\n\r\nconst formatNumber = {\r\n  format: (val) => {\r\n    if (!val) {\r\n      return '--';\r\n    }\r\n\r\n    return numberFormater.format(val);\r\n  },\r\n  asNumber: (val) => {\r\n    if (!val) {\r\n      return undefined;\r\n    }\r\n\r\n    return val.toNumber() / LAMPORTS_PER_SOL;\r\n  },\r\n};\r\n\r\nconst getAtaForMint = async (mint, buyer)=> {\r\n  return await anchor.web3.PublicKey.findProgramAddress(\r\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  );\r\n};\r\n\r\nconst getNetworkExpire = async (gatekeeperNetwork) => {\r\n  return await anchor.web3.PublicKey.findProgramAddress(\r\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\r\n    CIVIC,\r\n  );\r\n};\r\n\r\nconst getNetworkToken = async (wallet, gatekeeperNetwork) => {\r\n  return await anchor.web3.PublicKey.findProgramAddress(\r\n    [\r\n      wallet.toBuffer(),\r\n      Buffer.from('gateway'),\r\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\r\n      gatekeeperNetwork.toBuffer(),\r\n    ],\r\n    CIVIC,\r\n  );\r\n};\r\n\r\nfunction createAssociatedTokenAccountInstruction(\r\n  associatedTokenAddress,\r\n  payer,\r\n  walletAddress,\r\n  splTokenMintAddress,\r\n) {\r\n  const keys = [\r\n    {\r\n      pubkey: payer,\r\n      isSigner: true,\r\n      isWritable: true,\r\n    },\r\n    {\r\n      pubkey: associatedTokenAddress,\r\n      isSigner: false,\r\n      isWritable: true,\r\n    },\r\n    {\r\n      pubkey: walletAddress,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n    {\r\n      pubkey: splTokenMintAddress,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n    {\r\n      pubkey: SystemProgram.programId,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n    {\r\n      pubkey: TOKEN_PROGRAM_ID,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n    {\r\n      pubkey: SYSVAR_RENT_PUBKEY,\r\n      isSigner: false,\r\n      isWritable: false,\r\n    },\r\n  ];\r\n  return new TransactionInstruction({\r\n    keys,\r\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n    data: Buffer.from([]),\r\n  });\r\n}\r\n\r\nexport {\r\n  candyMachineProgram,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n  CIVIC,\r\n  toDate,\r\n  formatNumber,\r\n  getAtaForMint,\r\n  getNetworkExpire,\r\n  getNetworkToken,\r\n  createAssociatedTokenAccountInstruction,\r\n};\r\n"],"sourceRoot":""}